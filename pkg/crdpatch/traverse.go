package crdpatch

import (
	"fmt"
	"go/ast"
	"go/types"
	"strings"

	"sigs.k8s.io/controller-tools/pkg/deepcopy"
	"sigs.k8s.io/controller-tools/pkg/loader"
	"sigs.k8s.io/controller-tools/pkg/markers"
)

// patchMaker makes Patch (and related) methods for Go types,
// writing them to its codeWriter.
type patchMaker struct {
	pkg    *loader.Package
	object string
	path   string
	*deepcopy.ImportsList
	*deepcopy.CodeWriter
}

// GenerateMethodsFor makes Patch methods for the given type, when appropriate
func (p *patchMaker) GenerateMethodsFor(root *loader.Package, info *markers.TypeInfo) {
	fmt.Printf("\n\n\tgenerating methods for: %+v\n", info)
}

func (p *patchMaker) GeneratePatchTypeFor(root *loader.Package, info *markers.TypeInfo) {
	// TODO get Status from MarkerValues
	p.Linef("// %sPatch is an autogenerated Patch holder and generator", info.Name)
	p.Linef("type %sPatch struct {", info.Name)
	/*
	 * for _, field := range info.Fields {
	 *     if !ast.IsExported(field.Name) {
	 *         continue
	 *     }
	 *     jsonTag := strings.Replace(field.Tag.Get("json"), ",omitempty", "", 1)
	 *     fieldType := root.TypesInfo.TypeOf(field.RawField.Type)
	 *     valueType := types.TypeString(fieldType, types.RelativeTo(root.Types))
	 *     p.Linef("%s %s `json:\"%s\"`", field.Name, valueType, jsonTag)
	 * }
	 */
	p.Linef("data map[string]interface{}")
	p.Line("}")
}

func (p *patchMaker) GeneratePatchImplementationFor(root *loader.Package, info *markers.TypeInfo) {
	runtimeAlias := p.NeedImport("k8s.io/apimachinery/pkg/runtime")
	typesAlias := p.NeedImport("k8s.io/apimachinery/pkg/types")
	jsonAlias := p.NeedImport("encoding/json")
	p.genPatchInterfaceType(root, info, typesAlias)
	p.genPatchInterfaceData(root, info, runtimeAlias, jsonAlias)
}

func (p *patchMaker) genPatchInterfaceType(root *loader.Package, info *markers.TypeInfo, typesAlias string) {
	p.Linef(patchInterfaceTypeDef, info.Name, typesAlias)
}

func (p *patchMaker) genPatchInterfaceData(root *loader.Package, info *markers.TypeInfo, runtimeAlias, jsonAlias string) {
	var patchPathCode string
	// generate patch toward object
	if p.path != "" {
		// n := len(pathz)
		pathz := strings.Split(p.path, ".")
		var start, end string
		for _, path := range pathz {
			start += `{\"` + path + `\"` + ":"
			end += "}"
		}
		patchPathCode = fmt.Sprintf(`
if err == nil {
	data = append([]byte("%s"), data...)
	data = append(data[:], []byte("%s")...)
}
		`, start, end)
		// lines := make([]string, len(pathz)+2)
		// lines[0] = "if err == nil {"
		// lines = append(lines, "}")
		// patchPathCode = strings.Join(pathz, "\n")
	}

	p.Linef(patchInterfaceDataDef, info.Name, p.object, runtimeAlias, jsonAlias, patchPathCode)
}

// GenerateChangeMethodsFor makes Patch method and Change methods for fields
func (p *patchMaker) GenerateChangeMethodsFor(root *loader.Package, info *markers.TypeInfo) {
	p.genPatchMethod(info.Name)
	for _, field := range info.Fields {
		if ast.IsExported(field.Name) {
			if _, isBasic := root.TypesInfo.TypeOf(field.RawField.Type).(*types.Basic); isBasic {
				p.genChangeBasicFieldMethod(field, info.Name, root)
			}
		}
	}
}

func (p *patchMaker) genPatchMethod(name string) {
	p.Linef(patchMethodDef, name)
}

func (p *patchMaker) genChangeBasicFieldMethod(info markers.FieldInfo, name string, root *loader.Package) {
	fieldType := root.TypesInfo.TypeOf(info.RawField.Type)
	valueType := types.TypeString(fieldType, types.RelativeTo(root.Types))
	jsonName := strings.Split(info.Tag.Get("json"), ",")[0]
	p.Linef(changeBasicFieldMethodDef, info.Name, name, valueType, jsonName)
}

const (
	changeBasicFieldMethodDef = `
// Change%[1]s changes value of %[1]s to value
func (o %[2]s) Change%[1]s(value %[3]s, patch *%[2]sPatch) {
	// patch.%[1]s = value
	if patch.data == nil {
		patch.data = make(map[string]interface{})
	}
	if value == patch.data["%[4]s"] {
		delete(patch.data, "%[4]s")
	} else {
		patch.data["%[4]s"] = value
	}
}`

	patchMethodDef = `
// Patch returns a change holder to generate PATCH
func (p %[1]s) Patch() *%[1]sPatch {
	return &%[1]sPatch{}
}`

	patchInterfaceDataDef = `
// Data returns PATCH data for status changes
func (p *%[1]sPatch) Data(obj %[3]s.Object) (data []byte, err error) {
	if _, ok := obj.(*%[2]s); ok {
		data, err = %[4]s.Marshal(p.data)
		%[5]s
	}
	return
}`

	patchInterfaceTypeDef = `
// Type returns patch type
func (p *%[1]sPatch) Type() types.PatchType {
	return %[2]s.MergePatchType
}
`
)
